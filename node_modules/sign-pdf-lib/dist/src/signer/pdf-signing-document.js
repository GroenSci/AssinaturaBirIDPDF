"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PdfSigningDocument_pdfDoc, _PdfSigningDocument_pdf, _PdfSigningDocument_docSnapshot;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfSigningDocument = void 0;
const errors_1 = require("../errors");
const helpers_1 = require("../helpers");
const pdf_lib_1 = require("pdf-lib");
const _ = __importStar(require("lodash"));
function getSignatureRange(pdf) {
    let contentsStartIndex = 0;
    while (pdf[contentsStartIndex] != '<'.charCodeAt(0)) {
        contentsStartIndex = pdf.indexOf('/Contents', contentsStartIndex) + '/Contents'.length;
        while (pdf[contentsStartIndex] == ' '.charCodeAt(0)) {
            contentsStartIndex++;
        }
    }
    const start = pdf.indexOf('<', contentsStartIndex) + 1;
    const end = pdf.indexOf('>', start);
    return {
        start,
        end
    };
}
function getPdfSigningRanges(initialPdfLength, incrementalPdf) {
    const { start: startSignature, end: endSignature } = getSignatureRange(incrementalPdf);
    return {
        before: {
            start: 0,
            length: initialPdfLength + startSignature - 1
        },
        signature: {
            start: initialPdfLength + startSignature - 1,
            length: endSignature - startSignature + 2
        },
        after: {
            start: initialPdfLength + endSignature + 1,
            length: incrementalPdf.length - endSignature - 1
        }
    };
}
function updateByteRange(incrementalPdf, initialPdfLength) {
    const byteRangeStartIndex = incrementalPdf.indexOf('/ByteRange');
    if (byteRangeStartIndex < 0) {
        return undefined;
    }
    const { before, after } = getPdfSigningRanges(initialPdfLength, incrementalPdf);
    const byteRangeArray = pdf_lib_1.PDFContext.create().obj([before.start, before.length, after.start, after.length]);
    const startOfByteRange = incrementalPdf.indexOf('[', byteRangeStartIndex);
    const endOfByteRange = incrementalPdf.indexOf(']', startOfByteRange) + 1;
    if (endOfByteRange - startOfByteRange < byteRangeArray.sizeInBytes()) {
        throw new Error('Not enough space to store range.');
    }
    const byteRangeBuffer = Buffer.from(' '.repeat(endOfByteRange - startOfByteRange));
    byteRangeArray.copyBytesInto(byteRangeBuffer, 0);
    return Buffer.concat([
        incrementalPdf.subarray(0, startOfByteRange),
        byteRangeBuffer,
        incrementalPdf.subarray(endOfByteRange)
    ]);
}
function getSignBuffer(pdf, signRanges) {
    return Buffer.concat([
        pdf.subarray(signRanges.before.start, signRanges.before.start + signRanges.before.length),
        pdf.subarray(signRanges.after.start, signRanges.after.start + signRanges.after.length)
    ]);
}
class PdfSigningDocument {
    static fromPdfAsync(pdf) {
        return __awaiter(this, void 0, void 0, function* () {
            const pdfDoc = yield pdf_lib_1.PDFDocument.load(pdf);
            return new PdfSigningDocument(pdfDoc, pdf);
        });
    }
    constructor(pdfDoc, pdf) {
        _PdfSigningDocument_pdfDoc.set(this, void 0);
        _PdfSigningDocument_pdf.set(this, void 0);
        _PdfSigningDocument_docSnapshot.set(this, void 0);
        __classPrivateFieldSet(this, _PdfSigningDocument_pdfDoc, pdfDoc, "f");
        __classPrivateFieldSet(this, _PdfSigningDocument_pdf, pdf, "f");
        if (pdfDoc.context.pdfFileDetails.useObjectStreams) {
            pdfDoc.context.largestObjectNumber += 1;
        }
        ;
        __classPrivateFieldSet(this, _PdfSigningDocument_docSnapshot, pdfDoc.takeSnapshot(), "f");
    }
    registerDict(dict) {
        const obj = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj(dict);
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.register(obj);
    }
    getPageSize(pageIndex) {
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex).getSize();
    }
    getPageRef(pageIndex) {
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex).ref;
    }
    getDict(ref) {
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(ref, pdf_lib_1.PDFDict);
    }
    addDict(dict) {
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj(dict);
    }
    addPageAnnot(pageIndex, annotRef) {
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        if (!page.node.get(pdf_lib_1.PDFName.of('Annots'))) {
            page.node.set(pdf_lib_1.PDFName.of('Annots'), __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj([]));
        }
        const pageAnnots = page.node.lookup(pdf_lib_1.PDFName.of('Annots'), pdf_lib_1.PDFArray);
        pageAnnots.push(annotRef);
    }
    addFormField(fieldRef) {
        const formDict = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getForm().acroForm.dict;
        const formFields = formDict.lookup(pdf_lib_1.PDFName.of('Fields'), pdf_lib_1.PDFArray);
        formFields.push(fieldRef);
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markObjForSave(formDict);
    }
    addPageContent(visualRef, pageIndex) {
        this.ensurePageContentsArray(pageIndex);
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        const pageContents = page.node.lookup(pdf_lib_1.PDFName.of('Contents'), pdf_lib_1.PDFArray);
        pageContents.push(visualRef);
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.ref);
    }
    addPageResource(resourceRef, pageIndex, name) {
        this.ensurePageResourcesXObject(pageIndex);
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        const resources = page.node.lookup(pdf_lib_1.PDFName.of('Resources'), pdf_lib_1.PDFDict);
        const xObject = resources.lookup(pdf_lib_1.PDFName.of('XObject'), pdf_lib_1.PDFDict);
        xObject.set(pdf_lib_1.PDFName.of(name), resourceRef);
        if (page.node.get(pdf_lib_1.PDFName.of('Resources')) instanceof pdf_lib_1.PDFRef) {
            __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.node.get(pdf_lib_1.PDFName.of('Resources')));
        }
        else {
            __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.ref);
        }
    }
    registerStream(drawBuffer, visualObj) {
        const visual = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.stream(drawBuffer, visualObj);
        return __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.register(visual);
    }
    markObjAsChanged(obj) {
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markObjForSave(obj);
    }
    saveAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let incrementalPdf = Buffer.from(yield __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").saveIncremental(__classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f")));
            incrementalPdf = updateByteRange(incrementalPdf, __classPrivateFieldGet(this, _PdfSigningDocument_pdf, "f").length) || incrementalPdf;
            return Buffer.concat([
                __classPrivateFieldGet(this, _PdfSigningDocument_pdf, "f"),
                incrementalPdf
            ]);
        });
    }
    getPlaceholderRanges() {
        const signatureRefs = this.getSignatures();
        const lastSignatureRef = _.last(signatureRefs);
        if (!lastSignatureRef) {
            throw new errors_1.NoPlaceholderError();
        }
        const lastSignature = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(lastSignatureRef, pdf_lib_1.PDFDict);
        return (0, helpers_1.getPdfRangesFromSignature)(lastSignature);
    }
    ensureAcroForm() {
        if (__classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").catalog.AcroForm()) {
            return;
        }
        __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").catalog.getOrCreateAcroForm();
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markObjForSave(__classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").catalog);
        const formDict = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getForm().acroForm.dict;
        if (!formDict.has(pdf_lib_1.PDFName.of('SigFlags'))) {
            formDict.set(pdf_lib_1.PDFName.of('SigFlags'), pdf_lib_1.PDFNumber.of(3));
        }
    }
    ensurePageAnnots(pageIndex) {
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.ref);
        let annots = page.node.lookupMaybe(pdf_lib_1.PDFName.of('Annots'), pdf_lib_1.PDFArray);
        if (annots) {
            return;
        }
        annots = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj([]);
        page.node.set(pdf_lib_1.PDFName.of('Annots'), annots);
    }
    ensurePageContentsArray(pageIndex) {
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        const pageContents = page.node.get(pdf_lib_1.PDFName.of('Contents'));
        if (pageContents instanceof pdf_lib_1.PDFArray) {
            return;
        }
        const newPageContents = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj([pageContents]);
        page.node.set(pdf_lib_1.PDFName.of('Contents'), newPageContents);
        __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.ref);
    }
    ensurePageResourcesXObject(pageIndex) {
        const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageIndex);
        const resources = page.node.lookup(pdf_lib_1.PDFName.of('Resources'), pdf_lib_1.PDFDict);
        if (!resources.get(pdf_lib_1.PDFName.of('XObject'))) {
            const xObject = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj({});
            resources.set(pdf_lib_1.PDFName.of('XObject'), xObject);
            if (page.node.get(pdf_lib_1.PDFName.of('Resources')) instanceof pdf_lib_1.PDFRef) {
                __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.node.get(pdf_lib_1.PDFName.of('Resources')));
            }
            else {
                __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.ref);
            }
        }
    }
    embedImageAsync(image) {
        return __awaiter(this, void 0, void 0, function* () {
            let img;
            try {
                img = yield __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").embedJpg(image);
            }
            catch (_a) {
                try {
                    img = yield __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").embedPng(image);
                }
                catch (_b) {
                    throw new errors_1.InvalidImageError();
                }
            }
            yield img.embed();
            return img.ref;
        });
    }
    getSignatures() {
        if (!__classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").catalog.AcroForm()) {
            return [];
        }
        const formDict = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getForm().acroForm.dict;
        const formFields = formDict.lookup(pdf_lib_1.PDFName.of('Fields'), pdf_lib_1.PDFArray);
        return formFields.asArray()
            .filter(ref => {
            const dict = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookupMaybe(ref, pdf_lib_1.PDFDict);
            if (!dict) {
                return false;
            }
            return dict.lookupMaybe(pdf_lib_1.PDFName.of('FT'), pdf_lib_1.PDFName) == pdf_lib_1.PDFName.of('Sig')
                && dict.lookupMaybe(pdf_lib_1.PDFName.of('Type'), pdf_lib_1.PDFName) == pdf_lib_1.PDFName.of('Annot')
                && dict.lookupMaybe(pdf_lib_1.PDFName.of('Subtype'), pdf_lib_1.PDFName) == pdf_lib_1.PDFName.of('Widget');
        })
            .map(obj => obj)
            .map(ref => __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(ref, pdf_lib_1.PDFDict));
    }
    getSignature(name) {
        const signatures = this.getSignatures();
        for (let i = 0; i < signatures.length; i++) {
            const signature = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(signatures[i], pdf_lib_1.PDFDict);
            if (signature.lookup(pdf_lib_1.PDFName.of('T'), pdf_lib_1.PDFString).asString() === name) {
                return signature;
            }
            ;
        }
        ;
        throw new errors_1.SignatureNotFoundError(name);
    }
    getSignaturePageNumber(name) {
        for (let i = 0; i < __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPageCount(); i++) {
            const page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(i);
            const annotRefs = page.node.Annots();
            if (!annotRefs) {
                continue;
            }
            for (let j = 0; j < annotRefs.size(); j++) {
                const annot = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(annotRefs.get(j), pdf_lib_1.PDFDict);
                if (annot.has(pdf_lib_1.PDFName.of('T')) && annot.lookup(pdf_lib_1.PDFName.of('T'), pdf_lib_1.PDFString).asString() == name) {
                    return i + 1;
                }
            }
        }
        throw new errors_1.SignatureNotFoundError(name);
    }
    getSignatureBuffer(signature) {
        const signRanges = (0, helpers_1.getPdfRangesFromSignature)(signature);
        return getSignBuffer(__classPrivateFieldGet(this, _PdfSigningDocument_pdf, "f"), signRanges);
    }
    getSignatureHexString(signature) {
        const v = signature.lookup(pdf_lib_1.PDFName.of('V'), pdf_lib_1.PDFDict);
        let signatureHex = v.lookup(pdf_lib_1.PDFName.of('Contents'), pdf_lib_1.PDFHexString).asString();
        while (signatureHex[signatureHex.length - 1] == '0' && signatureHex[signatureHex.length - 2] == '0') {
            signatureHex = signatureHex.substring(0, signatureHex.length - 2);
        }
        return signatureHex;
    }
    isSignatureForEntireDocument(signature) {
        const signRanges = (0, helpers_1.getPdfRangesFromSignature)(signature);
        return signRanges.after.start + signRanges.after.length === __classPrivateFieldGet(this, _PdfSigningDocument_pdf, "f").length;
    }
    getSignatureCount() {
        return this.getSignatures().length;
    }
    getFields() {
        return this.getSignatures()
            .map(ref => __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(ref, pdf_lib_1.PDFDict))
            .filter(dict => !dict.has(pdf_lib_1.PDFName.of('V')));
    }
    embedSignatureFont(pageHint) {
        let page;
        if (pageHint instanceof pdf_lib_1.PDFRef) {
            page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.lookup(pageHint, pdf_lib_1.PDFDict);
        }
        else {
            page = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").getPage(pageHint).node;
        }
        const fontDict = page.lookup(pdf_lib_1.PDFName.of('Resources'), pdf_lib_1.PDFDict).lookup(pdf_lib_1.PDFName.of('Font'), pdf_lib_1.PDFDict);
        if (fontDict.has(pdf_lib_1.PDFName.of('Helvetica'))) {
            return;
        }
        const font = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.obj({
            'Type': 'Font',
            'Subtype': 'Type1',
            'BaseFont': 'Helvetica',
            'Encoding': 'WinAnsiEncoding'
        });
        const fontRef = __classPrivateFieldGet(this, _PdfSigningDocument_pdfDoc, "f").context.register(font);
        fontDict.set(pdf_lib_1.PDFName.of('Helvetica'), fontRef);
        if (page.get(pdf_lib_1.PDFName.of('Resources')) instanceof pdf_lib_1.PDFRef) {
            __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markRefForSave(page.get(pdf_lib_1.PDFName.of('Resources')));
        }
        else {
            __classPrivateFieldGet(this, _PdfSigningDocument_docSnapshot, "f").markObjForSave(page);
        }
    }
}
exports.PdfSigningDocument = PdfSigningDocument;
_PdfSigningDocument_pdfDoc = new WeakMap(), _PdfSigningDocument_pdf = new WeakMap(), _PdfSigningDocument_docSnapshot = new WeakMap();
