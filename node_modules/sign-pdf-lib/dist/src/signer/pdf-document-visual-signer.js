"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PdfDocumentVisualSigner_signingDoc;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfDocumentVisualSigner = void 0;
const pdf_signing_document_1 = require("./pdf-signing-document");
const errors_1 = require("../errors");
const helpers_1 = require("../helpers");
const pdf_lib_1 = require("pdf-lib");
;
;
class PdfDocumentVisualSigner {
    static fromPdfAsync(pdf) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingDoc = yield pdf_signing_document_1.PdfSigningDocument.fromPdfAsync(pdf);
            return new PdfDocumentVisualSigner(signingDoc);
        });
    }
    constructor(signingDoc) {
        _PdfDocumentVisualSigner_signingDoc.set(this, void 0);
        __classPrivateFieldSet(this, _PdfDocumentVisualSigner_signingDoc, signingDoc, "f");
    }
    addVisualSignatureAsync({ pageIndex, rectangle, texts, background, backgroundName, reverseY }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!texts && !background) {
                return;
            }
            const signatureCount = __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").getSignatureCount();
            if (signatureCount) {
                throw new errors_1.DigitallySignedError();
            }
            backgroundName = backgroundName || (0, pdf_lib_1.addRandomSuffix)('SignatureBackground');
            const pageSize = __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").getPageSize(pageIndex);
            const pageRect = (0, helpers_1.computeAbsolutePageReverseRectangle)(rectangle, pageSize);
            const left = pageRect.left;
            const bottom = pageRect.bottom;
            const width = pageRect.right - pageRect.left;
            const height = pageRect.bottom - pageRect.top;
            const backgroundRef = background ? yield __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").embedImageAsync(background) : undefined;
            let drawBuffer = '';
            if (backgroundRef) {
                drawBuffer =
                    'q'
                        + (reverseY ? ` 1 0 0 -1 0 ${pageSize.height} cm` : '')
                        + ` 1 0 0 -1 ${left} ${bottom} cm`
                        + ' 1 0 0 1 0 0 cm'
                        + ` ${width} 0 0 ${height} 0 0 cm`
                        + ' 1 0 0 1 0 0 cm'
                        + ` /${backgroundName} Do` + ' Q';
            }
            if (texts) {
                drawBuffer = drawBuffer
                    + ' q'
                    + (reverseY ? ` 1 0 0 -1 0 ${pageSize.height} cm` : '')
                    + ' 0 0 106 68 re'
                    + ` 1 0 0 1 ${left} ${bottom} cm`
                    + ' BT'
                    + ' /Helvetica 1 Tf'
                    + ' 0 Tc 0 Tw 0 Ts 100 Tz 0 Tr'
                    + ' 27.849 0 0 27.849 1 43.646 Tm'
                    + ` (${texts[0].lines[0]})Tj`
                    + ' 0 -1.2 TD'
                    + ` (${texts[0].lines[1]})Tj`
                    + ' 12.637 0 0 12.637 109.1188 54.087 Tm'
                    + ` (${texts[1].lines[0]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[1]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[2]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[3]})Tj`
                    + ' ET'
                    + ' Q';
            }
            const visualRef = __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").registerStream(drawBuffer, {});
            __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").addPageContent(visualRef, pageIndex);
            if (backgroundRef) {
                __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").addPageResource(backgroundRef, pageIndex, backgroundName);
            }
            if (texts) {
                __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").embedSignatureFont(pageIndex);
            }
        });
    }
    saveAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _PdfDocumentVisualSigner_signingDoc, "f").saveAsync();
        });
    }
}
exports.PdfDocumentVisualSigner = PdfDocumentVisualSigner;
_PdfDocumentVisualSigner_signingDoc = new WeakMap();
