"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PdfDigitalSigner_settings, _PdfDigitalSigner_signatureComputer;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfDigitalSigner = void 0;
const pdf_lib_1 = require("pdf-lib");
const pdf_document_digital_signer_1 = require("./pdf-document-digital-signer");
const signature_embeder_1 = require("./signature-embeder");
const signature_computer_1 = require("./signature-computer");
const pdf_signing_document_1 = require("./pdf-signing-document");
const signature_checker_1 = require("./signature-checker");
class PdfDigitalSigner {
    constructor(settings) {
        _PdfDigitalSigner_settings.set(this, void 0);
        _PdfDigitalSigner_signatureComputer.set(this, void 0);
        __classPrivateFieldSet(this, _PdfDigitalSigner_settings, settings, "f");
        __classPrivateFieldSet(this, _PdfDigitalSigner_signatureComputer, new signature_computer_1.SignatureComputer(settings.signatureComputer), "f");
    }
    addPlaceholderAsync(pdf, info) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const pdfDocSigner = yield pdf_document_digital_signer_1.PdfDocumentDigitalSigner.fromPdfAsync(pdf);
            const pageIndex = info.pageNumber - 1;
            const { background, texts } = (_a = info.visual) !== null && _a !== void 0 ? _a : {};
            const visualRef = yield pdfDocSigner.addVisualAsync({ background, texts });
            const placeholderInfo = this.getPlaceholderParameters();
            const placeholderRef = pdfDocSigner.addSignaturePlaceholder(Object.assign(Object.assign({}, info.signature), placeholderInfo));
            const rectangle = (_b = info.visual) === null || _b === void 0 ? void 0 : _b.rectangle;
            const embedFont = !!(info.visual && ((_c = info.visual) === null || _c === void 0 ? void 0 : _c.texts));
            const name = info.name;
            pdfDocSigner.addSignatureField({
                name,
                pageIndex,
                rectangle,
                visualRef,
                placeholderRef,
                embedFont,
            });
            return pdfDocSigner.saveAsync();
        });
    }
    addFieldAsync(pdf, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const pdfDocSigner = yield pdf_document_digital_signer_1.PdfDocumentDigitalSigner.fromPdfAsync(pdf);
            const pageIndex = info.pageNumber - 1;
            const rectangle = info.rectangle;
            const embedFont = false;
            const name = info.name;
            pdfDocSigner.addSignatureField({ name, pageIndex, rectangle, embedFont });
            return pdfDocSigner.saveAsync();
        });
    }
    signAsync(pdf, info) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const placeholderPdf = yield this.addPlaceholderAsync(pdf, info);
            const signatureEmbeder = yield signature_embeder_1.SignatureEmbeder.fromPdfAsync(placeholderPdf);
            const toBeSignedBuffer = signatureEmbeder.getSignBuffer();
            const signature = __classPrivateFieldGet(this, _PdfDigitalSigner_signatureComputer, "f").computeSignature(toBeSignedBuffer, ((_a = info.signature) === null || _a === void 0 ? void 0 : _a.date) || new Date());
            return signatureEmbeder.embedSignature(signature);
        });
    }
    signFieldAsync(pdf, info) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const pdfDocSigner = yield pdf_document_digital_signer_1.PdfDocumentDigitalSigner.fromPdfAsync(pdf);
            const placeholderInfo = this.getPlaceholderParameters();
            const placeholderRef = pdfDocSigner.addSignaturePlaceholder(Object.assign(Object.assign({}, info.signature), placeholderInfo));
            const visualRef = yield pdfDocSigner.addVisualAsync(Object.assign({}, info.visual));
            const embedFont = !!(info.visual && "texts" in info.visual);
            pdfDocSigner.updateSignature(info.fieldName, {
                placeholderRef,
                visualRef,
                embedFont,
            });
            const placeholderPdf = yield pdfDocSigner.saveAsync();
            const signatureEmbeder = yield signature_embeder_1.SignatureEmbeder.fromPdfAsync(placeholderPdf);
            const toBeSignedBuffer = signatureEmbeder.getSignBuffer();
            const signature = __classPrivateFieldGet(this, _PdfDigitalSigner_signatureComputer, "f").computeSignature(toBeSignedBuffer, ((_a = info.signature) === null || _a === void 0 ? void 0 : _a.date) || new Date());
            return signatureEmbeder.embedSignature(signature);
        });
    }
    verifySignaturesAsync(pdf) {
        return __awaiter(this, void 0, void 0, function* () {
            const signatureChecker = yield signature_checker_1.SignatureChecker.fromPdfAsync(pdf);
            return yield signatureChecker.verifySignaturesAsync();
        });
    }
    getFieldsAsync(pdf) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingDoc = yield pdf_signing_document_1.PdfSigningDocument.fromPdfAsync(pdf);
            return signingDoc.getFields().map((field) => {
                const name = field.lookup(pdf_lib_1.PDFName.of("T"), pdf_lib_1.PDFString).asString();
                const pageNumber = signingDoc.getSignaturePageNumber(name);
                return {
                    name,
                    pageNumber,
                };
            });
        });
    }
    getPlaceholderParameters() {
        return {
            signaturePlaceholder: "A".repeat(__classPrivateFieldGet(this, _PdfDigitalSigner_settings, "f").signatureLength),
            rangePlaceHolder: __classPrivateFieldGet(this, _PdfDigitalSigner_settings, "f").rangePlaceHolder,
        };
    }
}
exports.PdfDigitalSigner = PdfDigitalSigner;
_PdfDigitalSigner_settings = new WeakMap(), _PdfDigitalSigner_signatureComputer = new WeakMap();
