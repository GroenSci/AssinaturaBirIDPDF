"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NameProvider_signatureNumber, _PdfDocumentDigitalSigner_signingDoc, _PdfDocumentDigitalSigner_nameProvider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfDocumentDigitalSigner = void 0;
const pdf_signing_document_1 = require("./pdf-signing-document");
const helpers_1 = require("../helpers");
const errors_1 = require("../errors");
const pdf_lib_1 = require("pdf-lib");
class NameProvider {
    constructor(signatureNumber) {
        _NameProvider_signatureNumber.set(this, void 0);
        __classPrivateFieldSet(this, _NameProvider_signatureNumber, signatureNumber, "f");
    }
    getFrmName() {
        return `frm${__classPrivateFieldGet(this, _NameProvider_signatureNumber, "f")}`;
    }
    getBackgroundName() {
        return `background${__classPrivateFieldGet(this, _NameProvider_signatureNumber, "f")}`;
    }
    getSignatureName() {
        return `Signature${__classPrivateFieldGet(this, _NameProvider_signatureNumber, "f")}`;
    }
}
_NameProvider_signatureNumber = new WeakMap();
;
;
;
;
class PdfDocumentDigitalSigner {
    static fromPdfAsync(pdf) {
        return __awaiter(this, void 0, void 0, function* () {
            const signingDoc = yield pdf_signing_document_1.PdfSigningDocument.fromPdfAsync(pdf);
            return new PdfDocumentDigitalSigner(signingDoc);
        });
    }
    constructor(signingDoc) {
        _PdfDocumentDigitalSigner_signingDoc.set(this, void 0);
        _PdfDocumentDigitalSigner_nameProvider.set(this, void 0);
        __classPrivateFieldSet(this, _PdfDocumentDigitalSigner_signingDoc, signingDoc, "f");
        __classPrivateFieldSet(this, _PdfDocumentDigitalSigner_nameProvider, new NameProvider(__classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").getSignatureCount() + 1), "f");
    }
    addSignatureField({ name, pageIndex, rectangle, visualRef, placeholderRef, embedFont }) {
        __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").ensureAcroForm();
        __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").ensurePageAnnots(pageIndex);
        name = name || __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_nameProvider, "f").getSignatureName();
        const pageSize = __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").getPageSize(pageIndex);
        const pageRect = (0, helpers_1.computeAbsolutePageReverseRectangle)(rectangle, pageSize);
        const signature = {
            'FT': 'Sig',
            'Type': 'Annot',
            'Subtype': 'Widget',
            'T': pdf_lib_1.PDFString.of(name),
            'F': 132,
            'P': __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").getPageRef(pageIndex),
            'Rect': [pageRect.left, pageRect.top, pageRect.right, pageRect.bottom]
        };
        if (visualRef) {
            signature['AP'] = {
                'N': visualRef
            };
        }
        ;
        if (placeholderRef) {
            signature['V'] = placeholderRef;
        }
        const fieldRef = __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").registerDict(signature);
        __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").addPageAnnot(pageIndex, fieldRef);
        __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").addFormField(fieldRef);
        if (embedFont) {
            __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").embedSignatureFont(pageIndex);
        }
    }
    addVisualAsync({ background, texts }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!background && !texts) {
                return undefined;
            }
            let backgroundRef;
            if (background) {
                backgroundRef = yield __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").embedImageAsync(background);
                const drawBuffer2 = `q 1 0 0 1 0 0 cm /${__classPrivateFieldGet(this, _PdfDocumentDigitalSigner_nameProvider, "f").getBackgroundName()} Do Q`;
                const visualObj2 = {
                    'Type': 'XObject',
                    'Subtype': 'Form',
                    'BBox': [0.0, 0.0, 214.0, 70.0],
                    'Resources': {
                        'XObject': {
                            [`${__classPrivateFieldGet(this, _PdfDocumentDigitalSigner_nameProvider, "f").getBackgroundName()}`]: backgroundRef
                        }
                    }
                };
                backgroundRef = __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").registerStream(drawBuffer2, visualObj2);
            }
            let drawBuffer = backgroundRef
                ? `q 214 0 0 70 0 0 cm /${__classPrivateFieldGet(this, _PdfDocumentDigitalSigner_nameProvider, "f").getFrmName()} Do Q`
                : '';
            if (texts) {
                drawBuffer = drawBuffer
                    + ' q'
                    + ' 0 0 106 68 re'
                    + ' BT'
                    + ' /Helvetica 1 Tf'
                    + ' 0 Tc 0 Tw 0 Ts 100 Tz 0 Tr'
                    + ' 27.849 0 0 27.849 1 43.646 Tm'
                    + ` (${texts[0].lines[0]})Tj`
                    + ' 0 -1.2 TD'
                    + ` (${texts[0].lines[1]})Tj`
                    + ' 12.637 0 0 12.637 109.1188 54.087 Tm'
                    + ` (${texts[1].lines[0]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[1]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[2]})Tj`
                    + ' T*'
                    + ` (${texts[1].lines[3]})Tj`
                    + ' ET'
                    + ' Q';
            }
            const visualObj = {
                'FT': 'XObject',
                'Subtype': 'Form',
                'BBox': [0.0, 0.0, 214, 70.0],
                'Resources': {}
            };
            if (backgroundRef) {
                visualObj['Resources']['XObject'] = {
                    [`${__classPrivateFieldGet(this, _PdfDocumentDigitalSigner_nameProvider, "f").getFrmName()}`]: backgroundRef
                };
            }
            return __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").registerStream(drawBuffer, visualObj);
        });
    }
    addEmptyVisual() {
        const drawBuffer = '% DSBlank';
        const visualObj = {
            'FT': 'XObject',
            'Subtype': 'Form',
            'BBox': [0.0, 0.0, 214, 70.0],
        };
        return __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").registerStream(drawBuffer, visualObj);
    }
    addSignaturePlaceholder({ name, reason, location, contactInfo, date, signaturePlaceholder, rangePlaceHolder }) {
        const signature = {
            'Type': 'Sig',
            'Filter': 'Adobe.PPKLite',
            'SubFilter': 'adbe.pkcs7.detached',
            'Contents': pdf_lib_1.PDFHexString.of(signaturePlaceholder),
            'ByteRange': [0, rangePlaceHolder, rangePlaceHolder, rangePlaceHolder]
        };
        if (name) {
            signature['Name'] = pdf_lib_1.PDFString.of((0, helpers_1.escapeString)(name));
        }
        ;
        if (location) {
            signature['Location'] = pdf_lib_1.PDFString.of((0, helpers_1.escapeString)(location));
        }
        ;
        if (reason) {
            signature['Reason'] = pdf_lib_1.PDFString.of((0, helpers_1.escapeString)(reason));
        }
        ;
        if (date) {
            signature['M'] = pdf_lib_1.PDFString.fromDate(date);
        }
        ;
        if (contactInfo) {
            signature['ContactInfo'] = pdf_lib_1.PDFString.of((0, helpers_1.escapeString)(contactInfo));
        }
        ;
        return __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").registerDict(signature);
    }
    updateSignature(name, { placeholderRef, visualRef, embedFont }) {
        const signature = __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").getSignature(name);
        if (signature.get(pdf_lib_1.PDFName.of('V'))) {
            throw new errors_1.AlreadySignedError(name);
        }
        signature.set(pdf_lib_1.PDFName.of('V'), placeholderRef);
        if (visualRef) {
            if (!signature.get(pdf_lib_1.PDFName.of('AP'))) {
                signature.set(pdf_lib_1.PDFName.of('AP'), __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").addDict({}));
            }
            signature.lookup(pdf_lib_1.PDFName.of('AP'), pdf_lib_1.PDFDict).set(pdf_lib_1.PDFName.of('N'), visualRef);
        }
        else {
            signature.delete(pdf_lib_1.PDFName.of('AP'));
        }
        __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").markObjAsChanged(signature);
        if (embedFont) {
            __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").embedSignatureFont(signature.get(pdf_lib_1.PDFName.of('P')));
        }
    }
    saveAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").saveAsync();
        });
    }
    getPlaceholderRanges() {
        return __classPrivateFieldGet(this, _PdfDocumentDigitalSigner_signingDoc, "f").getPlaceholderRanges();
    }
}
exports.PdfDocumentDigitalSigner = PdfDocumentDigitalSigner;
_PdfDocumentDigitalSigner_signingDoc = new WeakMap(), _PdfDocumentDigitalSigner_nameProvider = new WeakMap();
