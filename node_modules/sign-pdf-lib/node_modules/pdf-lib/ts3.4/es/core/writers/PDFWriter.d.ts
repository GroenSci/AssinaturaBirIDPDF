import { DocumentSnapshot } from "../../api";
import PDFCrossRefSection from "../document/PDFCrossRefSection";
import PDFHeader from "../document/PDFHeader";
import PDFTrailer from "../document/PDFTrailer";
import PDFTrailerDict from "../document/PDFTrailerDict";
import PDFDict from "../objects/PDFDict";
import PDFObject from "../objects/PDFObject";
import PDFRef from "../objects/PDFRef";
import PDFContext from "../PDFContext";
export interface SerializationInfo {
    size: number;
    header: PDFHeader;
    indirectObjects: [PDFRef, PDFObject][];
    xref?: PDFCrossRefSection;
    trailerDict?: PDFTrailerDict;
    trailer: PDFTrailer;
}
declare class PDFWriter {
    static forContext: (context: PDFContext, objectsPerTick: number) => PDFWriter;
    static forContextWithSnapshot: (context: PDFContext, objectsPerTick: number, snapshot: DocumentSnapshot) => PDFWriter;
    protected readonly context: PDFContext;
    protected readonly objectsPerTick: number;
    protected readonly snapshot: DocumentSnapshot;
    private parsedObjects;
    protected constructor(context: PDFContext, objectsPerTick: number, snapshot: DocumentSnapshot);
    serializeToBuffer(): Promise<Uint8Array>;
    protected computeIndirectObjectSize([ref, object]: [PDFRef, PDFObject]): number;
    protected createTrailerDict(prevStartXRef?: number): PDFDict;
    protected computeBufferSize(incremental: boolean): Promise<SerializationInfo>;
    protected shouldWaitForTick: (n: number) => boolean;
}
export default PDFWriter;
//# sourceMappingURL=PDFWriter.d.ts.map
